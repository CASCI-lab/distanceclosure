{"name":"Distance Closure","tagline":"Distance Closure on Complex Networks (Backbone extraction)","body":"Distance Closure on Complex Networks (Backbone)\r\n===============================================\r\n\r\nDescription:\r\n-----------\r\n\r\nThis package implements some of the methods for the calculation of Distance Closure on Complex Networks. \r\nIt calculates network pairwise distance using the jaccard similarity/distance measure and transitive closure using both metric and ultrametric measures.\r\n\r\nThe mathematical description of the methods can be seen in:\r\n```\r\nT. Simas and L.M. Rocha [2015].\"Distance Closures on Complex Networks\". Network Science, 3(2):227-268. doi:10.1017/nws.2015.11\r\n```\r\n\r\nUsage:\r\n------\r\n\r\n```python\r\nfrom distanceclosure import pairwise_proximity, prox2dist, dist2prox, transitive_closure, backbone\r\n\r\n# Calculate Proximity and convert to Distance\r\nP = pairwise_proximity(X, metric='jaccard')\r\nD = prox2dist(P)\r\n\r\n# Calculate transitive closure using the metric and ultra-metric measure\r\nCm = transitive_closure(D, kind='metric')\r\nCu = transitive_closure(D, kind='ultrametric')\r\n\r\n# Retrieve the backbone edges\r\nBm = backbone(D, Cm)\r\nBu = backbone(D, Cu)\r\n```\r\n\r\nThe backbone edges on `Bm` and `Bu` can be accessed using \r\n\r\n```python\r\nimport numpy as np\r\nrows, cols = np.where(Bm==1)\r\n```\r\nwhere edges with a `1` are metric, `2` are semi-metric and `0` are non-existent. The diagonal is `-1`.\r\n\r\nNotes:\r\n-----\r\n\r\nThe current version of this code cannot handle extra large networks since it uses dense matrix computation.\r\n\r\nPull requests are welcome.\r\n\r\nHere are some TODOs:\r\n\r\n- Transitive closure (with custom distance metric) using the dijkstra algorithm;\r\n- Porting to Cython.\r\n\r\nTests:\r\n------\r\nRun `nosetests -v` to perform tests and diagnoses on functions.\r\n","google":"UA-71404006-1","note":"Don't delete this file! It's used internally to help with page regeneration."}